# L1 Policy-to-Code Map (Execution / Monitoring)

## Mapping Table

Scope: L1 paper loop, logging, state persistence, risk/kill-switch.
Rule: Read-only mapping. No code changes.


| Policy-Item              | Erwartung (konkret)                                                          | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                                                                                                                                                  | Status (OK/Gap) + Notiz                                                                                                     |
| ------------------------ | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- |
| L1-TICK-001 Loop cadence | decision_tick_seconds bestimmt Sleep und wird als sleep_s geloggt; 1 Hz Loop | `live_l1/core/loop.py:185 time.sleep(cfg.decision_tick_seconds)`; `live_l1/core/loop.py:183 fields={"tick": ticks, "sleep_s": cfg.decision_tick_seconds}`; `live_l1/core/loop.py:79 fields={"repo_root": repo_root, "decision_tick_seconds": cfg.decision_tick_seconds}` | **OK** – Sleep und Log-Feld sind direkt aus derselben Konfig-Quelle gespeist; Observation zeigte 199447 Ticks, WARN/ERROR=0 |



| Policy-Item         | Erwartung (konkret)                                                                     | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                                                                                                 | Status (OK/Gap) + Notiz                                                                       |
| ------------------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| L1-LOG-001 Log path | `live_logs/l1_paper.log` ist Source-of-Truth; optional via `L1_LOG_PATH` überschreibbar | `live_l1/core/loop.py:53 log_path = os.environ.get("L1_LOG_PATH", os.path.join(repo_root, "live_logs", "l1_paper.log"))`; `tools/l1_health_check.py:29 LOG_PATH = os.path.join(REPO_ROOT, "live_logs", "l1_paper.log")` | **OK** – zentraler Pfad, konsistent zwischen Loop und Health-Check, env-Override kontrolliert |


| Policy-Item           | Erwartung (konkret)                                                                                                                                    | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                                                                                                                                                                                                                                                      | Status (OK/Gap) + Notiz                                                                                                  |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| L1-LOG-002 Log schema | Jede Logzeile hat konsistente Basisfelder (timestamp_utc, category, event, severity) + system_state_id/seq aus Logger; Events sind kategorisiert L1–L6 | `live_l1/core/loop.py:75-77` (system_start mit category/event/severity); `live_l1/core/loop.py:90-92` (snapshot_received); `live_l1/core/loop.py:99-101` (data_valid/data_invalid + severity INFO/WARN); `live_l1/core/loop.py:111-113` (intent_created); `live_l1/core/loop.py:140-142` (order_not_sent); `live_l1/core/intent.py:26,34` (timestamp_utc via _utc_now_iso()) | **OK** – Schema ist strukturiert über category/event/severity, timestamp_utc wird zentral erzeugt; Events klar typisiert |


| Policy-Item                    | Erwartung (konkret)                                                 | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                         | Status (OK/Gap) + Notiz                                                                                    |
| ------------------------------ | ------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| L1-LOG-003 Severity discipline | WARN nur bei echten Ausnahme-/Risk-Ereignissen, INFO für Normalpfad | `live_l1/core/loop.py:101 severity=("INFO" if state.data_valid else "WARN")`; `live_l1/core/loop.py:129-131 kill_level_changed severity="WARN"` | **OK** – WARN ist an klaren Trigger gebunden (data_invalid, kill_level_changed); Observation zeigte WARN=0 |


| Policy-Item                  | Erwartung (konkret)                                                                                                               | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                                                                                                                                                            | Status (OK/Gap) + Notiz                                                               |
| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| L6-PERSIST-001 Persist files | Pro Tick wird State nach `live_state/` persistiert: `s2_position.jsonl` und `s4_risk.jsonl`; Log markiert Persist-Event mit Paths | `live_l1/core/loop.py:61 state_path_s2=.../live_state/s2_position.jsonl`; `live_l1/core/loop.py:62 state_path_s4=.../live_state/s4_risk.jsonl`; `live_l1/core/loop.py:171 event="state_persisted"`; `live_l1/core/loop.py:174 fields={"paths": "s2_position.jsonl,s4_risk.jsonl"}` | **OK** – kanonische Pfade im Code, Persist-Event explizit, deckt sich mit Observation |


| Policy-Item                | Erwartung (konkret)                                                                     | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                               | Status (OK/Gap) + Notiz                                                                                           |
| -------------------------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| L6-PERSIST-002 Append-only | JSONL-Dateien werden append-only beschrieben; keine stillen Truncates/Resets im L1-Code | **Negativbeleg:** keine `open(...,"w")`, kein Truncate, keine weiteren Referenzen in `live_l1/`; Suche nach Schreibmodi ergab nur Archiv-/Analysecode | **OK** – Persistenz erfolgt kontrolliert; Reset nur implizit durch neue Datei/Session (system_start dokumentiert) |


| Policy-Item                        | Erwartung (konkret)                                                                                                                                         | Code-Stelle (Datei:Zeile oder grep-Hit)                                                                                                                                                                                                                                                                                                                                                                                                                                       | Status (OK/Gap) + Notiz                                                                                                                                                                   |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| RISK-KILL-001 Kill-level semantics | Kill-Level ist explizit (NONE/SOFT/HARD/EMERGENCY), Guard entscheidet deterministisch, Transition wird geloggt, State trägt Kill-Level in s4 und Persistenz | `live_l1/state/models.py:24 kill_level: str  # NONE/SOFT/HARD/EMERGENCY`; `live_l1/guards/guards.py:43 kill_new = kill_level_current if ... else "NONE"`; `live_l1/guards/guards.py:53/58/65/68 GuardDecision(allowed=..., kill_level_new=...)`; `live_l1/core/loop.py:71 init kill_level="NONE"`; `live_l1/core/loop.py:125-133` (Transition + `event="kill_level_changed"` + fields from/to); `live_l1/core/loop.py:150-167` (RiskStateS4 + state_update + persist payload) | **OK** – Kill-Level ist typisiert, Guard-Entscheidung getrennt, Transition geloggt, Kill-Level wird in s4 propagiert und persistiert; Observation zeigte keine Transitionen (stabil NONE) |




## Notes / Findings
- (max 10 Zeilen, nur harte Fakten)
